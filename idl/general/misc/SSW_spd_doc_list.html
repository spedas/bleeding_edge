<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>general/misc/SSW</TITLE>
</head>
 
<body>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help2</CODE>.
<br>
<P>
<STRONG>Last modified: </STRONG>Wed Aug  6 18:18:26 2025.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>Directory Listing of Routines</H1></A>
<UL>
<H1>general/misc/SSW</H1>
<LI><A HREF="#BITS2">BITS2</A>
<br>Given a byte or integer, return a vector of 8 or 16 values
<LI><A HREF="#BSORT">BSORT</A>
<br>Function to sort data into ascending order, like a simple bubble sort.
<LI><A HREF="#DIR_STR_REPLACE">DIR_STR_REPLACE</A>
<br>take all of the files in a given directory and replace strings
<LI><A HREF="#DPRINT">DPRINT</A>
<br>Diagnostic PRINT (activated only when DEBUG reaches DLEVEL)
<LI><A HREF="#F2PL">F2PL</A>
<br>Calculates values the double power law
<LI><A HREF="#F3PL">F3PL</A>
<br>Calculates values for the triple power law
<LI><A HREF="#FILE_STR_REPLACE">FILE_STR_REPLACE</A>
<br>read a file, find a substring and replace it in an SVN working copy
<LI><A HREF="#IN_SET">IN_SET</A>
<LI><A HREF="#IS_ARRAY">IS_ARRAY</A>
<LI><A HREF="#IS_NUM">IS_NUM</A>
<LI><A HREF="#IS_STRING">IS_STRING</A>
<LI><A HREF="#IS_STRUCT">IS_STRUCT</A>
<LI><A HREF="#LOGICAL_XOR">LOGICAL_XOR</A>
<LI><A HREF="#SSL_NEWLINE">SSL_NEWLINE</A>
<br>Returns a cross-platform newline character.
<LI><A HREF="#SSW_STR_REPLACE">SSW_STR_REPLACE</A>
<LI><A HREF="#SSWHERE_ARR">SSWHERE_ARR</A>
<br>gives the subscripts in the array arr1 that are for elements
<LI><A HREF="#TAG_EXIST">TAG_EXIST</A>
<LI><A HREF="#UNDEFINE">UNDEFINE</A>
<br>The purpose of this program is to delete or undefine
<LI><A HREF="#WIDGET_VALID">WIDGET_VALID</A>
<br>
</UL><P>
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="BITS2">
<H2>BITS2</H2></A>
<A HREF="#BSORT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	bits2
PURPOSE:
	Given a byte or integer, return a vector of 8 or 16 values
	which are the binary representation of the value.
INPUT:
	invalue	- The byte or integer value to check
OUTPUT:
	bitarr	- The 8-element array with values set
		  if the bit is set
HISTORY:
	Written 19-dec-1996, RAS after BITS by M.Morrison
	but correcting negative integer problems and returning
	32 byte arrays for longwords regardless of maximum value
	17-feb-2001 loop index long.
       9-apr-2009, jmm, replaced datatype call with size and case
       statement hacked from bitplot.pro
	
</PRE><P>
<STRONG>(See <A href="SSW/bits2.pro">general/misc/SSW/bits2.pro</A>)</STRONG><P>
<HR>
 
<A NAME="BSORT">
<H2>BSORT</H2></A>
<A HREF="#BITS2">[Previous Routine]</A>
<A HREF="#DIR_STR_REPLACE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       BSORT
 PURPOSE:
       Function to sort data into ascending order, like a simple bubble sort.
 EXPLANATION:
       Original subscript order is maintained when values are equal (FIFO).
       (This differs from the IDL SORT routine alone, which may rearrange 
       order for equal values)

 NOTE: this routine is originally from the NASA GSFC IDL Astro Library.
   http://idlastro.gsfc.nasa.gov/

 CALLING SEQUENCE:  
       result = bsort( array, [ asort, /INFO, /REVERSE ] )

 INPUT:
       Array - array to be sorted

 OUTPUT:
       result - sort subscripts are returned as function value

 OPTIONAL OUTPUT:
       Asort - sorted array

 OPTIONAL KEYWORD INPUTS:
       /REVERSE - if this keyword is set, and non-zero, then data is sorted
                 in descending order instead of ascending order.
       /INFO = optional keyword to cause brief message about # equal values.

 HISTORY
       written by F. Varosi Oct.90:
       uses WHERE to find equal clumps, instead of looping with IF ( EQ ).
       compatible with string arrays, test for degenerate array 
       20-MAY-1991     JKF/ACC via T AKE- return indexes if the array to 
                       be sorted has all equal values.
       Aug - 91  Added  REVERSE keyword   W. Landsman      
       Always return type LONG    W. Landsman     August 1994
       Converted to IDL V5.0   W. Landsman   September 1997
       Added to TDAS P.Cruce Jun 2008

$LastChangedBy: pcruce $
$LastChangedDate: 2008-07-01 14:43:50 -0700 (Tue, 01 Jul 2008) $
$LastChangedRevision: 3230 $
$URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/spdsoft/trunk/general/misc/SSW/bsort.pro $

</PRE><P>
<STRONG>(See <A href="SSW/bsort.pro">general/misc/SSW/bsort.pro</A>)</STRONG><P>
<HR>
 
<A NAME="DIR_STR_REPLACE">
<H2>DIR_STR_REPLACE</H2></A>
<A HREF="#BSORT">[Previous Routine]</A>
<A HREF="#DPRINT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
 dir_str_replace
PURPOSE:
 take all of the files in a given directory and replace strings
 works recursively. Also renames files
CALLING SEQUENCE:
 dir_str_replace, directory, string, replacement, filter=filter
INPUT:
 directory = a directory name, scalar
 string = a string to replace, can be vector
 replacement = the replacement string, can be a vector the same size
               as the input string
 no_svn = if set, do the string replacement to the output filename,
          but don't mess with svn.
 move_it = if set, use svn mv, and not svn cp
HISTORY:
 5-Jan-2010, jmm, jimm@ssl.berkeley.edu
</PRE><P>
<STRONG>(See <A href="SSW/dir_str_replace.pro">general/misc/SSW/dir_str_replace.pro</A>)</STRONG><P>
<HR>
 
<A NAME="DPRINT">
<H2>DPRINT</H2></A>
<A HREF="#DIR_STR_REPLACE">[Previous Routine]</A>
<A HREF="#F2PL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 PROJECT:
       General Purpose
       SOHO - CDS/SUMER
       THEMIS

 NAME:
       DPRINT

 PURPOSE:
       Diagnostic PRINT (activated only when DEBUG reaches DLEVEL)

 EXPLANATION:
       This routine acts similarly to the PRINT command, except that
       it is activated only when the common block variable DEBUG is
       set to be equal to or greater than the debugging level set by
       DLEVEL (default to 0).  It is useful for debugging.
       If DLEVEL is not provided it uses a persistent (common block) value set with the
       keyword SETDEBUG.

 CALLING SEQUENCE (typically written into code):
       DPRINT, v1 [,v2 [,v3...]]] [,format=format] [,dlevel=dlevel] [,verbose=verbose]
             The values of v1,v2,v3 will only be printed if verbose &gt;= dlevel

 CALLING SEQUENCE to change options (typically typed from IDL command line - Don't put these lines in code!!!)
       DPRINT, setdebug=2   ; define persistent debug level (2 is typical level)
       DPRINT, SETVERBOSE=2 ; Same as above
       DPRINT, print_trace=[0,1,2,3, or 4]  ; Display program trace info in subsequent calls to DPRINT
       DPRINT, /print_dlevel      ; Display current dlevel and verbose settings.
       DPRINT, /print_dtime       ; Display delta time between DPRINT statements.

 INPUTS:
       V1, V2, ... - List of variables to be printed out (20 max).

 OPTIONAL INPUTS:
       None.

 OUTPUTS:
       All input variables are printed out on the screen (or the
       given unit)

 OPTIONAL Keywords:
       FORMAT - Output format to be used
       UNIT   - Output unit through which the variables are printed. If
                missing, the standard output (i.e., your terminal) is used.

 KEYWORD PARAMETERS:
       DLEVEL = DLEVEL - An integer indicating the debugging level; defaults to 0
       VERBOSE = VERBOSE - An integer indicating current verbosity level, If verbose is set
       it will override the current value of SETVERBOSE, for the specific call of dprint in which
       it is set.
       SETVERBOSE=value            - Set debug level to value
       SETDEBUG=value            - Same as SETVERBOSE
       GETDEBUG=named variable   - Get current debug level
       DWAIT = NSECONDS  ; provides an additional constraint on printing.
              It will only print if more than NSECONDS has elapsed since last dprint.
       CHECK_EVENTS= [0,1]    -    If set then WIDGET events are captured and processed within DPRINT
       BREAK_DETECTED= named variable   - Used to break out of user routines (see DPRINTTOOL)


 COMMON BLOCKS:
       DPRINT_COM.

 RESTRICTIONS:
     - Changed see SETDEBUG above
       Can print out a maximum of 20 variables (depending on how many
          is listed in the code)

 SIDE EFFECTS:
       Generally None.

 CATEGORY:
       Utility, miscellaneous

 PREVIOUS HISTORY:
       Written March 18, 1995, Liyun Wang, GSFC/ARC

 MODIFICATION HISTORY:
       Version 1, Liyun Wang, GSFC/ARC, March 18, 1995
       Version 2, Zarro, SM&amp;A, 30 November 1998 - added error checking
       Version 3, Zarro, (EIT/GSFC), 23 Aug 2000 - removed DATATYPE calls
       Version 4, Larson  (2007) stripped out calls to &quot;execute&quot; so that it can be called from IDL VM
                          Fixed bug that allows format keyword to be used.
                          Added SETDEBUG keyword and GETDEBUG keyword
                          Added DWAIT keyword
                          Added PRINT_TRACE,PRINT_DTIME,PRINT_DLEVEL
                          Added Widget options
 $LastChangedBy: ali $
 $LastChangedDate: 2020-03-05 13:24:53 -0800 (Thu, 05 Mar 2020) $
 $LastChangedRevision: 28381 $
 $URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/spdsoft/trunk/general/misc/SSW/dprint.pro $

</PRE><P>
<STRONG>(See <A href="SSW/dprint.pro">general/misc/SSW/dprint.pro</A>)</STRONG><P>
<HR>
 
<A NAME="F2PL">
<H2>F2PL</H2></A>
<A HREF="#DPRINT">[Previous Routine]</A>
<A HREF="#F3PL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	f2pl
 CALLING SEQUENCE:
	f=f2pl(ax,x)
 PURPOSE:
	Calculates values the double power law
 INPUT:
	ax= fit parameters, [slope, intercept, slope, intercept]
	x = value input
 OUTPUT:
	f=ax[0]+ax[1]*x, below xbr
	f=ax[2]+ax[3]*x, above xbr, where
       xbr = (ax[2]-ax[0])/(ax[1]-ax[3])
 HISTORY:
	Spring '92 JMcT

</PRE><P>
<STRONG>(See <A href="SSW/f2pl.pro">general/misc/SSW/f2pl.pro</A>)</STRONG><P>
<HR>
 
<A NAME="F3PL">
<H2>F3PL</H2></A>
<A HREF="#F2PL">[Previous Routine]</A>
<A HREF="#FILE_STR_REPLACE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	f3pl
 CALLING SEQUENCE:
	f=f3pl(ax,x)
 PURPOSE:
	Calculates values for the triple power law
 INPUT:
	ax= fit parameters, [slope, intercept, slope, intercept,
	slope, intercept]
	x = value input
 OUTPUT:
	f=ax[0]+ax[1]*x, below xbr1
	f=ax[2]+ax[3]*x, above xbr1, where
       xbr1 = (ax[2]-ax[0])/(ax[1]-ax[3])
       f=ax[4]+ax[5]*x, above xbr2, where
       xbr2 = (ax[4]-ax[2])/(ax[3]-ax[5])
 HISTORY:
	Spring '92 JMcT

</PRE><P>
<STRONG>(See <A href="SSW/f3pl.pro">general/misc/SSW/f3pl.pro</A>)</STRONG><P>
<HR>
 
<A NAME="FILE_STR_REPLACE">
<H2>FILE_STR_REPLACE</H2></A>
<A HREF="#F3PL">[Previous Routine]</A>
<A HREF="#IN_SET">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
 file_str_replace
PURPOSE:
 read a file, find a substring and replace it in an SVN working copy
 using str_replace function. Only do this for files with '.txt',
 '.pro' extensions.
CALLING SEQUENCE:
 file_str_replace, file, string, replacement, out_filename=out_filename
INPUT:
 file = a filename, note that the file will be rewritten unless
        the out_filename is set
 string = a string to replace, can be a vector
 replacement = the replacement string, can be a vector, with the same
               number of elements as the other string.
KEYWORDS:
 out_filename = if set, then write to this file
          if not set, svn cp the original file to the output file prior
          to replacement. In this case the string in will be replaced
          in the filename by the new string, if present.
 no_svn = if set, do the string replacement to the output filename,
          but don't mess with svn.
 move_it = if set, use svn mv, and not svn cp
HISTORY:
 1-aug-2013, jmm, jimm@ssl.berkeley.edu
</PRE><P>
<STRONG>(See <A href="SSW/file_str_replace.pro">general/misc/SSW/file_str_replace.pro</A>)</STRONG><P>
<HR>
 
<A NAME="IN_SET">
<H2>IN_SET</H2></A>
<A HREF="#FILE_STR_REPLACE">[Previous Routine]</A>
<A HREF="#IS_ARRAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 function: in_set
 
 purpose: simple boolean function to check whether an element is a member of 
          a set(array).  It is mainly syntactic sugar for a frequently repeated
          operation.
          
 inputs: ele: The element to be searched for
         set: The set to be searched
         
 output: 1=yes, 0=no
 
 $LastChangedBy: pcruce $
 $LastChangedDate: 2008-11-10 12:47:28 -0800 (Mon, 10 Nov 2008) $
 $LastChangedRevision: 3952 $
 $URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/spdsoft/trunk/general/misc/SSW/in_set.pro $
</PRE><P>
<STRONG>(See <A href="SSW/in_set.pro">general/misc/SSW/in_set.pro</A>)</STRONG><P>
<HR>
 
<A NAME="IS_ARRAY">
<H2>IS_ARRAY</H2></A>
<A HREF="#IN_SET">[Previous Routine]</A>
<A HREF="#IS_NUM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>

Name: is_array

Purpose: determines if input is an array

Inputs: input: the input can of any type

Outputs: 1:yes 0:no

 $LastChangedBy: pcruce $
 $LastChangedDate: 2008-09-15 16:21:35 -0700 (Mon, 15 Sep 2008) $
 $LastChangedRevision: 3498 $
 $URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/spdsoft/trunk/general/misc/SSW/is_array.pro $
</PRE><P>
<STRONG>(See <A href="SSW/is_array.pro">general/misc/SSW/is_array.pro</A>)</STRONG><P>
<HR>
 
<A NAME="IS_NUM">
<H2>IS_NUM</H2></A>
<A HREF="#IS_ARRAY">[Previous Routine]</A>
<A HREF="#IS_STRING">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>

Name: is_num

Purpose: determines if input is a number

Inputs: num: the number can be single element or array

Outputs: 1:yes 0:no

Keywords: unsigned: set this if you only want to know if it is
                    unsigned
          signed: set this if you only want to know if it is signed
 
          real: set this if you want to know only if it is real

          complex: set this if want to know only if it is complex

          floating: set this if you want to know if it is floating
                    point
          
          integer: set this is you want to know if it is not floating point
          
          single: set this if you want to know if it is single precision floating point
          
          double: set this if you want to know if it is double precision floating point


 NOTES: if you can think of other classes of number worth testing
that involve more than one idl type feel free to add
        if you specify and impossible numerical class like: 
        b = is_num(1,/signed,/unsigned) 
           -or-
        b = is_num(1,/unsigned,/complex)

        it will return 0

LAST MODIFICATION:  02/11/01
 $LastChangedBy: davin-win $
 $LastChangedDate: 2007-10-22 07:26:16 -0700 (Mon, 22 Oct 2007) $
 $LastChangedRevision: 1758 $
 $URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/ssl_general/trunk/tplot/tplot.pro $
</PRE><P>
<STRONG>(See <A href="SSW/is_num.pro">general/misc/SSW/is_num.pro</A>)</STRONG><P>
<HR>
 
<A NAME="IS_STRING">
<H2>IS_STRING</H2></A>
<A HREF="#IS_NUM">[Previous Routine]</A>
<A HREF="#IS_STRUCT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 Project     : HESSI
                  
 Name        : IS_STRING
               
 Purpose     : return true is input is a non-blank string
                             
 Category    : string utility
               
 Syntax      : IDL&gt; a=is_string(input)
    
 Inputs      : INPUT_STR = input variable to check
                              
 Outputs     : 0/1 if blank/nonblank

 Keywords    : return true (1), even if string is blank
               
 Opt. Outputs: NONBLANK = noblank copies of input
               (if input is array, then nonblanks are filtered out)
             
 History     : 17-Nov-1999, Zarro (SM&amp;A/GSFC)
                5-Feb-2003, Zarro (EER/GSFC) - added /BLANK

 Contact     : dzarro@solar.stanford.edu
</PRE><P>
<STRONG>(See <A href="SSW/is_string.pro">general/misc/SSW/is_string.pro</A>)</STRONG><P>
<HR>
 
<A NAME="IS_STRUCT">
<H2>IS_STRUCT</H2></A>
<A HREF="#IS_STRING">[Previous Routine]</A>
<A HREF="#LOGICAL_XOR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 Project     :	HESSI

 Name        :	is_struct

 Purpose     :	returns, 1/0 if valid/invalid input structure

 Category    :	Structure handling

 Syntax      : IDL&gt; output=is_struct(input)

 Inputs      :	INPUT = input structure array

 Outputs     :	OUTPUT = 1/0

 Written     : Zarro (EITI/GSFC), 17 Sept 2001

 Contact     : dzarro@solar.stanford.edu
</PRE><P>
<STRONG>(See <A href="SSW/is_struct.pro">general/misc/SSW/is_struct.pro</A>)</STRONG><P>
<HR>
 
<A NAME="LOGICAL_XOR">
<H2>LOGICAL_XOR</H2></A>
<A HREF="#IS_STRUCT">[Previous Routine]</A>
<A HREF="#SSL_NEWLINE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>

function: Logical_xor


Purpose:
  IDL has logical_and, and logical_or, but not logical_xor
  This routine add this capability 
 
 $LastChangedBy: pcruce $
 $LastChangedDate: 2009-06-12 11:33:39 -0700 (Fri, 12 Jun 2009) $
 $LastChangedRevision: 6178 $
 $URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/spdsoft/trunk/general/misc/SSW/logical_xor.pro $
</PRE><P>
<STRONG>(See <A href="SSW/logical_xor.pro">general/misc/SSW/logical_xor.pro</A>)</STRONG><P>
<HR>
 
<A NAME="SSL_NEWLINE">
<H2>SSL_NEWLINE</H2></A>
<A HREF="#LOGICAL_XOR">[Previous Routine]</A>
<A HREF="#SSWHERE_ARR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
  ssl_newline

PURPOSE:
  Returns a cross-platform newline character.
  Specifically, used in the dialog_message boxes, which tend to
  print junk characters if character 13 is used on non-windows platforms

CALLING SEQUENCE:
  newline = ssl_newline()
  string = line1 + ssl_newline() + line2

INPUT:
 none
 
OUTPUT:
 Newline character

HISTORY:

$LastChangedBy: aaflores $
$LastChangedDate: 2013-10-28 12:44:04 -0700 (Mon, 28 Oct 2013) $
$LastChangedRevision: 13414 $
$URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/spdsoft/trunk/general/misc/SSW/ssl_newline.pro $
</PRE><P>
<STRONG>(See <A href="SSW/ssl_newline.pro">general/misc/SSW/ssl_newline.pro</A>)</STRONG><P>
<HR>
 
<A NAME="SSWHERE_ARR">
<H2>SSWHERE_ARR</H2></A>
<A HREF="#SSL_NEWLINE">[Previous Routine]</A>
<A HREF="#SSW_STR_REPLACE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	sswhere_arr
 CALLING SEQUENCE:
	ss=sswhere_arr(arr1, arr2)
 PURPOSE:
	gives the subscripts in the array arr1 that are for elements
	of arr2.
 INPUT:
	arr1, arr2 = two arrays
 OUTPUT:
	ss = the subscripts of arr1 that are also in arr2
 KEYWORD:
       notequal = if set, return the array elements of arr1 that are
                  not in arr2
 HISTORY
	Spring '92 JMcT
       Added notequal, extra, jun 2007, jmm
       Testing SVN, 20-jan-2009, jmm
</PRE><P>
<STRONG>(See <A href="SSW/sswhere_arr.pro">general/misc/SSW/sswhere_arr.pro</A>)</STRONG><P>
<HR>
 
<A NAME="SSW_STR_REPLACE">
<H2>SSW_STR_REPLACE</H2></A>
<A HREF="#SSWHERE_ARR">[Previous Routine]</A>
<A HREF="#TAG_EXIST">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
   Name: ssw_str_replace

   Purpose: replace all occurences of a substring with a replacement 
	     if no replacement string is specified, a NULL is inserted 

   Input Parameters:
      source - source string (vector ok) 
      insub - target string for replace
      outsub - replacement string - default is NULL String (per 2001 mod)
               (pre 2001 default was a BLANK)

   Calling Example:
      new=ssw_str_replace(strings,'old','new') ; 
      new=ssw_str_replace(strings,'asdfa,' ')  ; replace 'asdfa' with ' '
      new=ssw_str_replace(strings,'x','')      ; remove 'x' (-&gt; null)
      new=ssw_str_replace(strings,'x')         ; same (default=NULL)

   History: slf, 11/19/91
            slf, 19-mar-93	; optimize case where insub and outsub
				; are each 1 character in length
	     mdm, 21-Jul-97	; patch to handle big arrays
            fz,  12-May-98     ; change loop variable to long
            Zarro (EITI/GSFC), 17-Mar-01, used STRPOS instead of WHERE
            when checking for delimiters
            26-Jul-2005 - S.L.Freeland - DOCUMENTATION ONLY
                          changed Documented default delimiter from blank 
                          to null since the CODE default was changed in 
                          the 2001 modification
            Zarro (L-3Com/GSFC), 23-Oct-05; protect against insub/outsub 
                          coming in as vectors
            Zarro (ADNET), 30-Jan-09; added additional checks for
                           insub/outsub coming in as vectors
            Zarro (ADNET), 11-June-10, increased string limit to 200000
            jmm, 23-sep-2013, renamed to avoid name conflict with
                              ssl_general str_replace.pro, replaced
                              str2arr and arr2str with strsplit,
                              strjoin.
</PRE><P>
<STRONG>(See <A href="SSW/ssw_str_replace.pro">general/misc/SSW/ssw_str_replace.pro</A>)</STRONG><P>
<HR>
 
<A NAME="TAG_EXIST">
<H2>TAG_EXIST</H2></A>
<A HREF="#SSW_STR_REPLACE">[Previous Routine]</A>
<A HREF="#UNDEFINE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 Project     : SOHO - CDS     
                   
 Name        : TAG_EXIST()
               
 Purpose     : To test whether a tag name exists in a structure.
               
 Explanation : Routine obtains a list of tagnames and tests whether the
               requested one exists or not. The search is recursive so 
               if any tag names in the structure are themselves structures
               the search drops down to that level.  (However, see the keyword
		TOP_LEVEL).
               
 Use         : IDL&gt;  status = tag_exist(str, tag)
    
 Inputs      : str  -  structure variable to search
               tag  -  tag name to search for
               
 Opt. Inputs : None
               
 Outputs     : Function returns 1 if tag name exists or 0 if it does not.
               
 Opt. Outputs: None
               
 Keywords    : INDEX	  = Index of matching tag

		TOP_LEVEL = If set, then only the top level of the structure is
			    searched.
               RECURSE  = set to recurse on nested structures
               
 Category    : Util, structure

 Written     : C D Pike, RAL, 18-May-94
               
 Modified    : Version 1.1, D Zarro, ARC/GSFC, 27-Jan-95
               Passed out index of matching tag
		Version 2, William Thompson, GSFC, 6 March 1996
			Added keyword TOP_LEVEL
               Version 2.1, Zarro, GSFC, 1 August 1996
                       Added call to help 
               Version 3, Zarro, EIT/GSFC, 3 June 2000
                       added check for input array structure
               Version 4, Zarro, EIT/GSFC, 23 Aug 2000
                       removed calls to DATATYPE
               Version 5, Zarro, EIT/GSFC, 29 Sept 2000
                       added /quiet
               Version 6, Zarro (EER/GSC), 22 Dec 2002
                       made recursion NOT the default
               Removed datatype calls, jmm, 4-jun-2007 
</PRE><P>
<STRONG>(See <A href="SSW/tag_exist.pro">general/misc/SSW/tag_exist.pro</A>)</STRONG><P>
<HR>
 
<A NAME="UNDEFINE">
<H2>UNDEFINE</H2></A>
<A HREF="#TAG_EXIST">[Previous Routine]</A>
<A HREF="#WIDGET_VALID">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       UNDEFINE

 PURPOSE:
       The purpose of this program is to delete or undefine
       an IDL program variable from within an IDL program or
       at the IDL command line. It is a more powerful DELVAR.

 AUTHOR:
       FANNING SOFTWARE CONSULTING
       David Fanning, Ph.D.
       1642 Sheely Drive
       Fort Collins, CO 80526 USA
       Phone: 970-221-0438
       E-mail: davidf@dfanning.com
       Coyote's Guide to IDL Programming: http://www.dfanning.com

 CATEGORY:
       Utilities.

 CALLING SEQUENCE:
       UNDEFINE, variable

 REQUIRED INPUTS:
       variable: The variable to be deleted. Up to 10 variables may be specified as arguments.

 SIDE EFFECTS:
       The variable no longer exists.

 EXAMPLE:
       To delete the variable &quot;info&quot;, type:

        IDL&gt; Undefine, info

 MODIFICATION HISTORY:
       Written by David Fanning, 8 June 97, from an original program
       given to me by Andrew Cool, DSTO, Adelaide, Australia.
       Simplified program so you can pass it an undefined variable. :-) 17 May 2000. DWF
       Simplified it even more by removing the unnecessary SIZE function. 28 June 2002. DWF.
       Added capability to delete up to 10 variables at suggestion of Craig Markwardt. 10 Jan 2008. DWF.
</PRE><P>
<STRONG>(See <A href="SSW/undefine.pro">general/misc/SSW/undefine.pro</A>)</STRONG><P>
<HR>
 
<A NAME="WIDGET_VALID">
<H2>WIDGET_VALID</H2></A>
<A HREF="#UNDEFINE">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 Project     : Solar-B

 Name        : widget_valid

 Purpose     : check if variable is a valid widget id

 Category    : utility widgets

 Syntax      : IDL&gt; s=widget_valid(id)

 Inputs      : ID = id to check

 Outputs     : 1/0 if it is or isn't

 Keywords    : None

 History     : 12-Jan-2006, Zarro (L-3Com/GSFC) - written

 Contact     : DZARRO@SOLAR.STANFORD.EDU
</PRE><P>
<STRONG>(See <A href="SSW/widget_valid.pro">general/misc/SSW/widget_valid.pro</A>)</STRONG><P>
<HR>
 
